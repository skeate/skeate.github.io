= How Seque Works
:hp-tags: seque, javascript

=== What even is this?

https://github.com/skeate/seque[Seque] is a library of chainable control flow functions -- in other words, it allows you to write code like this:

[source,javascript]
----
[1, 2, 3]
  .if(useEvens)
  .filter(x => x % 2 === 0)
  .else()
  .filter(x => x % 2 === 1)
  .endif()
  .forEach(doSomething)
  // ...
----

How does it work? First, a quick recap of what's really going on in a chain:

+++
<p data-height="147" data-theme-id="16793" data-slug-hash="yNEKwg" data-default-tab="result" data-user="skeate" class='codepen'>See the Pen <a href='http://codepen.io/skeate/pen/yNEKwg/'>Basic Chain</a> by Jonathan Skeate (<a href='http://codepen.io/skeate'>@skeate</a>) on <a href='http://codepen.io'>CodePen</a>.</p>
+++

Each step returns a value, which the next function in the chain is then invoked upon. Chained functions have no knowledge of each other.

=== Wrappers Galore

To get around this, Seque uses a `wrap` function. Essentially, it returns an object which will intercept any function you try to call on it. It stashes these away until some endpoint (e.g. `endif()`), and then executes a callback with the entire list of functions that had been "called", along with their arguments. The callback can then decide to apply them or not apply them as it sees fit.

[IMPORTANT]
====
Technically, it will only intercept _any_ function if the platform has ES6 `Proxy` support. More on that in a bit.
====

All of Seque's control flow methods use this `wrap` method, with differing callbacks. `if` 's callback, for example, splits the chain where the `else` call is (if it exists), and then applies the stack before or after the else based on the value it was passed.

An attempt at illustrating this point (press arrow buttons at the top to change slides):

+++
<p data-height="268" data-theme-id="16793" data-slug-hash="VLdXJq" data-default-tab="result" data-user="skeate" class='codepen'>See the Pen <a href='http://codepen.io/skeate/pen/VLdXJq/'>Seque chain</a> by Jonathan Skeate (<a href='http://codepen.io/skeate'>@skeate</a>) on <a href='http://codepen.io'>CodePen</a>.</p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>
+++

=== Caveat

Without ES6's new `Proxy` feature, doing this in a completely seamless way is (as far as I can tell) impossible. Without it, the `wrap` function can only track those functions it has some way of knowing about. By default, it will track any functions available on the original object it was called upon -- if an array, it'll watch for calls to `map` or `forEach`, for example. But if some link in the chain returns a different type, then you could have problems if you try to call a function that didn't exist (at least by name) on the original object.

For example, something like this will work:

[source,javascript]
----
['a', 'b', 'c', ...]
  .if(someCondition)
  .join('')
  .slice(1)
  .endif()
----

Because `slice` is available on both arrays and strings. However, this will fail:

[source,javascript]
----
['a', 'b', 'c', ...]
  .if(someCondition)
  .join('')
  .toUpperCase()
  .endif()
----

Because `toUpperCase()` does *not* exist on arrays. The Seque-wrapped version of the original array will not know that it should be looking for some function named `toUpperCase`, and thus when it encounters that in the chain, it will say `undefined is not a function` (or something along those lines).

There is a way around this issue: pass an array of the extra function names as a second argument to the control flow function. Thus, the above failing example would become

[source,javascript]
----
['a', 'b', 'c', ...]
  .if(someCondition, ['toUpperCase'])
  .join('')
  .toUpperCase()
  .endif()
----

Admittedly, this is a bit gross, but I can think of no other way around a lack of proper `Proxy` support, at least in the code itself. One _possible_ way would be to make a Seque preprocessor, so the array of function names would be generated for you.

=== Chaining Asynchrony with Promises