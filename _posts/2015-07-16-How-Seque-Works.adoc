= How Seque Works
:hp-tags: seque, javascript

=== What even is this?

https://github.com/skeate/seque[Seque] is a library of chainable control flow functions -- in other words, it allows you to write code like this:

[source,javascript]
----
[1, 2, 3]
  .if(useEvens)
  .filter(x => x % 2 === 0)
  .else()
  .filter(x => x % 2 === 1)
  .endif()
  .forEach(doSomething)
  // ...
----

How does it work? First, a quick recap of what's really going on in a chain:

+++
<p data-height="147" data-theme-id="16793" data-slug-hash="yNEKwg" data-default-tab="result" data-user="skeate" class='codepen'>See the Pen <a href='http://codepen.io/skeate/pen/yNEKwg/'>Basic Chain</a> by Jonathan Skeate (<a href='http://codepen.io/skeate'>@skeate</a>) on <a href='http://codepen.io'>CodePen</a>.</p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>
+++

Each step returns a value, which the next function in the chain is then invoked upon. Chained functions have no knowledge of each other.

=== Wrappers Galore

To get around this, Seque uses a `wrap` function. Essentially, it returns an object which will intercept any function you try to call on it. It stashes these away until some endpoint (e.g. `endif()`), and then executes a callback with the entire list of functions that had been "called", along with their arguments. The callback can then decide to apply them or not apply them as it sees fit.

[IMPORTANT]
====
Technically, it will only intercept _any_ function if the platform has ES6 `Proxy` support. More on that in a bit.
====

All of Seque's control flow methods use this `wrap` method, with differing callbacks. `if` 's callback, for example, splits the chain where the `else` call is (if it exists), and then applies the stack before or after the else based on the value it was passed.

An attempt at illustrating this point:

